#! /bin/sh

# deblob-check version 2008-03-27.1
# Inspired in gNewSense's find-firmware script.
# Written by Alexandre Oliva <lxoliva@fsfla.org>

# Copyright (C) 2008 Alexandre Oliva
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301
# USA


# usage: deblob-check [-VV] [-s S] [-lDdBbCcXxPpFft] [*.tar* patch-* *.patch]

# Look for too-long undocumented sequences of numbers (generally blobs
# in disguise) in source files.

# -V --verbose: increase verbosity level, for internal debugging.  May
#		be given at most twice.

# -s --sensitivity: must be followed by a blank and a number.
#		Specifies the number of consecutive integral or
#		character constants that trigger the blob detector.

# The default sensitivity is 32 constants.

# The sensitivity, if present, must be the first option.  The action
# selection, if present, must be the first argument, except for the
# sensitivity and verbosity.

# The default can be overridden with one of:

# -l --list-blobs: list files that contain sequences that match the
#		blob detector test and that are not known to be false
#		positives.  This is the default option.

# -D --deblob --mark-blobs: print the processed input, replacing
#		sequences that match the blob detector test and that
#		are NOT known to be false positives with
#		/*(DEBLOBBED)*/.

# -d --cat: print the processed input, as it would have been fed to
#		the blob detector.

# -B --print-marked-blobs: like -d, but print only the matching
#		sequences.

# -b --print-blobs: like -B, but do not deblob the sequences.

# -C --print-marked-blobs-with-context: like -B, but try to maximize
#		the context around the blobs.  This maximization can
#		be quite CPU-intensive.

# -c --print-blobs-with-context: like -b, but try to maximize the
#		context around the blobs.  Also quite intensive.

# -X --print-all-matches: print all blobs, be they known false
#		positives or blobs.

# -x --list-all-matches: list files that contain sequences that appear
#		to be blobs, be they known false positives or not.

# -P --mark-false-positives: print the processed input, replacing
#		sequences that match the blob detector test, but that
#		are known to be false positives, with /*(DEBLOBBED)*/.

# -p --list-false-positives: list files that contain false positives.

# -F --print-marked-false-positives: like -P, but print only the
#		matching sequences.

# -f --print-false-positives: like -F, but do not deblob the sequences.

# -t --test: run (very minimal) self-test.

# -v --version: print a version number

# -h -? --help: print short or long help message

# The exit status in all cases is success if nothing was printed, and
# failure if anything (except for the tester's success message) was
# printed.

# Choose verbosity level for sed script debugging and performance
# analysis.
case $1 in
--verbose | -V)
  shift
  case $1 in
  --verbose | -V)
    shift
    v="i\\
:
p;
i\\
"
    ;;
  *)
    v="P;i\\
"
    ;;
  esac
  ;;
*) 
  v="# "
  ;;
esac

sens=31 # 32 - 1
case $1 in
--sensitivity | -s)
  sens=$2;
  shift 2 || exit 1

  if test "$sens" -gt 0 2>/dev/null; then
    :
  else
    echo invalid sensitivity: $sens >&2
    exit 1
  fi

  sens=`expr $sens - 1`
  ;;
esac

test_mode=false

name=deblob-check

case $1 in
--version | -v)
  sed '/^# '$name' version /,/^# Written by/ { s/^# //; p; }; d' < $0
  exit 0
  ;;

-\?|-h)
  sed -n '/^# usage:/,/# -h/ { /^# -/,/^$/{s/^# \(-.*\):.*/\1/p; d; }; s/^\(# \?\)\?//p; }' < $0 &&
  echo
  echo "run \`$name --help | more' for full usage"
  exit 0
  ;;

--help)
  sed -n '/^# '$name' version /,/^[^#]/ s/^\(# \?\)\?//p' < $0
  exit 0
  ;;

--test | -t)
  test_mode=:
  ;;

--mark-false-positives | -P)
  shift;
  set_sed_cmd () {
    set_sedmain -f "p;" "P;" "b deblob;" "" "p; d;"
  }
  ;;

--print-marked-false-positives | -F)
  shift;
  set_sed_cmd () {
    set_sedmain -f "" "" "b deblob;" "i\\
::: $file :::
p; d;" "d;"
  }
  ;;

--print-false-positives | -f)
  shift;
  set_sed_cmd () {
    set_sedmain -f "" "" "i\\
::: $file :::
p;" "d;" "d;"
  }
  ;;

--deblob | --mark-blobs | -D)
  shift;
  set_sed_cmd () {
    set_sedmain -f "b deblob;" "P;" "p; d;"
  }
  ;;

--cat | -d)
  shift;
  set_sed_cmd () {
    set_sedmain -f "p; d;" "P;" "p; d;"
  }
  ;;

--print-marked-blobs | -B)
  shift;
  set_sed_cmd () {
    set_sedmain -f "b deblob;" "" "d;" "i\\
::: $file :::
  p; d;"
  }
  ;;

--print-blobs | -b)
  shift;
  set_sed_cmd () {
    set_sedmain -f "i\\
::: $file :::
  p;"
  }
  ;;

--print-marked-blobs-with-context | -C)
  shift;
  set_sed_cmd () {
    set_sedmain "b deblob;" "" "d;" "i\\
::: $file :::
  p; d;"
  }
  ;;

--print-blobs-with-context | -c)
  shift;
  set_sed_cmd () {
    set_sedmain "i\\
::: $file :::
  p;"
  }
  ;;

--list-false-positives | -p)
  shift;
  set_sed_cmd () {
    set_sedmain -f "" "" "i\\
$file
  q" "d;" "d;"
  }
  ;;

--list-all-matches | -x)
  shift;
  set_sed_cmd () {
    set_sedmain -f "i\\
$file
  q;" "" "i\\
$file
  q" "d;" "d;"
  }
  ;;

--print-all-matches | -X)
  shift;
  set_sed_cmd () {
    set_sedmain -f "b deblob" "" "b deblob;" "i\\
::: $file :::
p; d;" "d;"
  }
  ;;

*)
  case $1 in
  -- | -l | --list-blobs) shift;;
  esac
  set_sed_cmd () {
    set_sedmain -f "i\\
$file
  q;"
  }
  ;;

esac

case $1 in
--) shift;;
esac

if $test_mode; then
  pass=:

  # Exercise some nasty inputs to see that we recognize them as blobs
  # with full context.
  for string in \
    "1,2,3,4" \
    "= {
1, 0x2, 03, L'\x4'
}" \
    "=
{
  '\\x1', '\\002'
  ,
  {
    { \"\\x3\", },
    \"\\004\"
  },
};" \
    ".long 1,2
     .long \$3,\$4" \
    "#define X { 1, 2, \\
		 3, 4, /* comment */ \\
	       }" \
  "= {
/*
 * multi-line
 * comment
 */
 {
   0x4c00c000, 0x00000000, 0x00060000, 0x00000000,
 },
}" \
  ; do
    case `echo "$string" | $0 -s 4 -c` in
    "::: - :::
$string") ;;
    *) echo "failed positive test for:
$string" >&2
       pass=false;;
    esac
  done

  # Make sure we do not recognize these as blobs.
  for string in \
    "#define X { 1, 2 }
#define Y { 3, 4 }" \
    " 0x00, 0x00, 0x00 " \
  ; do
    case `echo "$string" | $0 -s 4` in
    "") ;;
    *) echo "failed negative test for:
$string" >&2
       pass=false;;
    esac
  done

  # How did we do?
  if $pass; then
    echo success
  fi

  $pass
  exit
fi

# Set variables sedx, spex and spefx, to recognize blobs that are
# known to be false positives.  See the general process in set_sedmain
# to get a better idea of how these fit in.

# sedx is supposed to be a sequence of sed commands of the form
# "/^regex/b notblob;", one per line (blank lines and comment lines
# are ok), that recognize the beginning of known false positives.  For
# performance reasons, it should be anchored to the beginning of the
# pattern, and any line break in it must be by itself in "[\n]", in
# the top level (i.e., not within "\(\)"s or before or after a
# top-level "\|").  If all patterns are of the correct form, sedx will
# be optimized to a single large regex, which should probably speed
# things up in case of long-running pattern matches.  False positive
# patterns should be as specific as possible.  There should be some
# way to match the files a pattern appears in.  So far, there isn't.

# sedfx is extracted from sedx, as an additional optimization.  This
# is what depends on [\n]s not being involved in alternations or
# compositions.  Basically, the pre-\n portion of each expression will
# be extracted and turned into a single pattern anchored on the end of
# the line, such that we can recognize single lines that may mark the
# beginning of a false positive sequence.  It's a terrible idea,
# performance-wise, to use an initial match that is too broad.

# spex is similar in form "/^regex/b collect_begin;", but it can be
# used to start the process of recognizing a sequence, in case it
# doesn't match the standard forms of starting a sequence.

# This function is called before starting processing each file, with
# the file name as the first argument.

set_except () {
  sedx= spex=
  case /$1 in
  */linux*.tar* | */kernel*.tar* | */linux-*.*.*/*)
    spex='
    # arch/powerpc/lib/copyuser_64.S
    /^	\.section __ex_table,"a"$/b collect_begin;
    '
    sedx='
    # false alarms, contain source
    # drivers/net/wan/wanxlfw.inc_shipped -> wanxlfw.S
    /^static u8 firmware\[\]={.*0x23,0xFC,0x00,0x00,0x00,0x01,0xFF,0xF9,0x00,0xD4,0x61,0x00,0x06,0x74,0x33,0xFC,/b notblob;
    # drivers/usb/serial/xircom_pgs_fw.h -> xircom_pgs.S
    /^static const struct ezusb_hex_record xircom_pgs_firmware\[\] =/b notblob;
    # drivers/usb/serial/keyspan_pda_fw_h -> keyspan_pda.S
    /^static const struct ezusb_hex_record keyspan_pda_firmware\[\] =/b notblob;
    # arch/m68k/ifpsp060/*.sa -> src/*.s
    /^	\.long	0x60ff0000,0x02360000,0x60ff0000,0x16260000/b notblob;
    /^	\.long	0x60ff0000,0x17400000,0x60ff0000,0x15f40000/b notblob;
    # arch/powerpc/platforms/cell/spufs/spu_save_dump.h_shipped -> spu_save.c
    /^static unsigned int spu_save_code\[\]  __attribute__((__aligned__(128))) =/b notblob;
    # arch/powerpc/platforms/cell/spufs/spu_restore_dump.h_shipped -> spu_restore.c
    /^static unsigned int spu_restore_code\[\]  __attribute__((__aligned__(128))) =/b notblob;
    # drivers/net/ixp2000/ixp2400_tx.ucode -> ixp2400_tx.uc
    /^	\.initial_reg_values	= (struct ixp2000_reg_value \[\]) {/b notblob;
    # drivers/net/ixp2000/ixp2400_rx.ucode -> ixp2400_rx.uc
    /^	\.initial_reg_values	= (struct ixp2000_reg_value \[\]) {/b notblob;
    # crypto/tcrypt.h
    /^[ 	]*\.\(digest\|entries\|input\|key\|output\|plaintext\|result\)[ 	]*= {/b notblob;

    # checked:

    /^	\$3 = {{pge = .*<repeats 11 times>}/b notblob;
    /^__clz_tab:[\n]	\.byte	0\(,[0-5]\)\+[\n]/b notblob;
    /^PITBL:[\n]  \.long  0xC0040000,0xC90FDAA2/b notblob;
    # arch/m68k/mac/mac_penguin.S
    /^\(0x[0F][0F],\)\+\\[\n]\(\(0x[0F][0F],\)\+\\[\n]\)*\(0x[0F][0F],\)\+0x00/b notblob;
    # arch/s390/kernel/head.S
    /^\.lowcase:[\n]	\.byte 0x00\(,0x0[1-7]\)\+[\n]/b notblob;
    # arch/s390/kernel/bitmap.S
    /^_zb_findmap:[\n]         \.byte  0\(,[123],0\)\+,4[\n]/b notblob;
    /^_sb_findmap:[\n]         \.byte  8\(,0,[123]\)\+,0[\n]/b notblob;
    # arch/powerpc/lib/copyuser_64.S
    /^	\.section __ex_table,"a"/b notblob;
    # arch/powerpc/platforms/iseries/mf.c
    /^	memcpy(src, "\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00".*PROGxxxx/b notblob;
    # arch/ppc/platforms/ev64260.c
    /^static const unsigned int cpu_745x\[2\]\[16\] =/b notblob;
    # arch/alpha/lib/fls.c
    /^const unsigned char __flsm1_tab\[256\] =/b notblob;
    # drivers/input/misc/map_to_7segment.h
    /^#define _MAP_0_32_ASCII_SEG7_NON_PRINTABLE	\\[\n]	\(0,\)\+\([\n]\|$\)/b notblob;
    /^	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[\n][\n]#define _MAP_33_47_ASCII_SEG7_SYMBOL/b notblob;
    # sound/oss/ad1848.c
    /^	static int      init_values_b\[\] =/b notblob;
    # drivers/input/keyboard/atkbd.c
    /^static unsigned char atkbd_set2_keycode\[512\] =/b notblob;
    # drivers/usb/serial/keyspan_pda.S and
    # drivers/usb/serial/xircom_pgs.S
    /^	\.byte 0x41, .*[\n]string_\(mfg\|product\)_end:/b notblob;
    # drivers/media/video/pwc/pwc-nala.h
    /^      {0, 0, {0x04, 0x01, 0x03}},/b notblob;
    # drivers/video/logo/*.ppm
    /^P[13][\n]\(#.*[\n][\n]*\)*\([ ]*[0-9]*[\n]\)*/b notblob;
    # Documentation/specialix.txt
    /^for i in [ 	0-9\\\n]*[\n]do/b notblob;
    # Documentation/cpu-freq/cpufreq-stats.txt
    /^         :   3600000   3400000   3200000   3000000   2800000 /b notblob;
    # Documentation/scsi/sym53c8xx_2.txt and
    # Documentation/scsi/ncr53c8xx_2.txt
    /^00 00[\n]64 01[\n]8e 0b[\n][\n][0-9a-f \n]*fe fe/b notblob;
    /^0f 00 08 08 64 00 0a 00 - id 0[\n]/b notblob;
    /^default nvram data:/b notblob;
    # Documentation/video4linux/sn9c102.txt
    /^0x0458     0x7025[\n]/b notblob;
    # Documentation/video4linux/et61x251.txt
    /^0x102c     0x6151[\n]/b notblob;
    # Documentation/video4linux/zc0301.txt
    /^0x041e     0x4017[\n]/b notblob;
    # Documentation/uml/UserModeLinux-HOWTO.txt
    /^  (gdb) x\/100x \$25[\n]  0x507d2434:     0x507d2434      0x00000000      0x08048000      0x080a4f8c/b notblob;
    # Documentation/isdn/README.inc
    /^      1  0  0  0  0x308[\n]/b notblob;
    # Documentation/sched-stats.txt
    /^domain<N> <cpumask> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36[\n]/b notblob;
    # net/ipv4/ipvs/ip_vs_sync.c and
    # net/sctp/sm_make_chunk.c and
    # include/linux/sctp.h
    /^[ *	]*0                   1                   2                   3[\n][ *	]*0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1/b notblob;
    # arch/x86/lguest/boot.c
    /^ \*  1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0/b notblob;
    # drivers/net/fealnx.c
    /^	[/][*] Configure the PCI bus bursts and FIFO thresholds./b notblob;
    # drivers/hwmon/via686a.c
    /^\/\* the original LUT values from Alex van Kaam <darkside@chello\.nl>/b notblob;

    # quite suspicious
    # arch/parisc/kernel/perf_images.h
    /^static uint32_t onyx_images\[\]\[PCXU_IMAGE_SIZE\/sizeof(uint32_t)\] __read_mostly =/b notblob;
    /^static uint32_t cuda_images\[\]\[PCXW_IMAGE_SIZE\/sizeof(uint32_t)\] __read_mostly =/b notblob;

    # too lax?
    /^static yyconst flex_int\(16\|32\)_t yy_[^[]*\[[][0-9]*\] =/b notblob;
    /^static const yytype_u\?int\(8\|16\) yy[^[]*\[\] =/b notblob;
    /^\(\|	\)static \(const \|\)\(unsigned \(short\|char\)\|struct SiS_[^ ]*\) SiS[^[]*\(\[[] [*0-9]*\]\)\+ *=/b notblob;

    /^static const a3d_Hrtf_t A3dHrirZeros = {/b notblob;
    /^static const a3d_Hrtf_t A3dHrirImpulse = {/b notblob;
    /^static const a3d_Hrtf_t A3dHrirOnes = {/b notblob;
    /^static const a3d_Hrtf_t A3dHrirSatTest = {/b notblob;
    /^static const a3d_Hrtf_t A3dHrirDImpulse = {/b notblob;
    /^static const a3d_ItdDline_t A3dItdDlineZeros = {/b notblob;
    /^static auxxEqCoeffSet_t asEqCoefsNormal = {/b notblob;
    /^static xtalk_dline_t const alXtalkDlineTest = {/b notblob;
    /^static struct nand_ecclayout rtc_from4_nand_oobinfo = {/b notblob;
    /^static const s16 tempLUT\[\] =/b notblob;
    /^static const u8 viaLUT\[\] =/b notblob;
    /^static struct { int xres, yres, left, right, upper, lower, hslen, vslen, vfreq; } timmings\[\] __initdata = {/b notblob;
    /^static struct platinum_regvals platinum_reg_init_[0-9]* = {/b notblob;
    /^} sisfb_ddc[sf]modes\[\] __devinitdata =/b notblob;
    /^static struct dvb_pll_desc .* = {/b notblob;
    /^static u32 LABELPATCHES\[\] __attribute((unused)) =/b notblob;

    /^static dbdev_tab_t dbdev_tab\[\] =/b notblob;
    /^\(EXP\|LOG\|ATAN\)TBL:/b notblob;
    /^static char fm_volume_table\[128\] =/b notblob;
    /^unsigned int snd_gf1_scale_table\[SNDRV_GF1_SCALE_TABLE_SIZE\] =/b notblob;
    # remaining after original deblob_2_6_24, not fully checked

    /^#define OV51[18]_\(Y\|UV\)QUANTABLE {/b notblob;
    /^		static unsigned char const data_bit\[64\] =/b notblob;
    /^		static const u8 data_sbit\[32\] =/b notblob;
    /^	\.RightCoefs =/b notblob;
    /^	#define WakeupSeq    {/b notblob;
    /^	SetRate44100\[\] =/b notblob;
    /^	const short period\[32\] =/b notblob;
    /^	const static int desc_idx_table\[\] =/b notblob;
    /^	int prop_bcomm_irq\[3\*16\] =/b notblob;
    /^	static char logSlopeTable\[128\] =/b notblob;
    /^	static const int uc_\(dup\|word\)_table\[\]\[2\] =/b notblob;
    /^	static const struct mc7_timing_params mc7_timings\[\] =/b notblob;
    /^	static const u8 biphase_tbl\[\] =/b notblob;
    /^	static const u8 cs170\[7 \* 8\] =/b notblob;
    /^	static const u8 cs3[13]a\[8 \* 4\] =/b notblob;
    /^	static const u8 dramsr13\[12 \* 5\] =/b notblob;
    /^	static const u8 log10\[\] =/b notblob;
    /^	static const u8 mpeg_hdr_data\[\] =/b notblob;
    /^	static const u8 sdramtype\[13\]\[5\] =/b notblob;
    /^	static const u8 t\[\] =/b notblob;
    /^	static const unsigned int avg_pkts\[NCCTRL_WIN\] =/b notblob;
    /^	static const unsigned short ac97_defaults\[\] =/b notblob;
    /^	static int exp_lut\[256\] =/b notblob;
    /^	static u16 jpeg_tables\[\]\[70\] =/b notblob;
    /^	static u16 tables\[\] =/b notblob;
    /^	static u32 logMagTable\[128\] =/b notblob;
    /^	static u8 init_bufs\[13\]\[5\] =/b notblob;
    /^	static u8 sine \[\] =/b notblob;
    /^	static u_short geometry_table\[\]\[[45]\] =/b notblob;
    /^	static unsigned char CRCTable1\[\] =/b notblob;
    /^	static unsigned char CRCTable2\[\] =/b notblob;
    /^	static unsigned char default_colors\[\] =/b notblob;
    /^	static unsigned char iso_regs\[8\]\[4\] =/b notblob;
    /^	static unsigned char log_scale\[101\] =/b notblob;
    /^	static unsigned char msg\[\] =/b notblob;
    /^	static unsigned char static_pad\[\] =/b notblob;
    /^	static unsigned char table_alaw2ulaw\[\] =/b notblob;
    /^	static unsigned char table_ulaw2alaw\[\] =/b notblob;
    /^	u32 reg_boundaries\[\] =/b notblob;
    /^	u8 b\[\] =/b notblob;
    /^	uint8_t tx\[\] =/b notblob;
    /^	unsigned char saa7111_regs\[\] =/b notblob;
    /^	unsigned char sas_pcd_m_pg\[\] =/b notblob;
    /^	} modedb\[5\] =/b notblob;
    /^	} reg_tbl\[\] =/b notblob;
    /^	} vals\[\] =/b notblob;
    /^	} vm_devices\[\] =/b notblob;
    /^    static const code distfix\[32\] =/b notblob;
    /^    static const code lenfix\[512\] =/b notblob;
    /^  int poly\[\]=/b notblob;
    /^  static const unsigned char asso_values\[\] =/b notblob;
    /^  static unsigned char asso_values\[\] =/b notblob;
    /^  } cards_ds\[\] =/b notblob;
    /^    static const int8 countLeadingZerosHigh\[\] =/b notblob;
    /^    static const unsigned short d\(base\|ext\)\[32\] =/b notblob;
    /^#define OV511_QUANTABLESIZE	64/b notblob;
    /^desc_config1:/b notblob;
    /^BYTE BtCard::SRAMTable_\(NTSC\|PAL\)\[\] =/b notblob;
    /^BYTE SRAMTable\[\]\[ 60 \] =/b notblob;
    /^irq_prio_[hdlc]*:/b notblob;
    /^__u8 _ascebc\[256\] =/b notblob;
    /^__u8 _ebc_tolower\[256\] =/b notblob;
    /^__u8 _ebc_toupper\[256\] =/b notblob;
    /^adapter_tag_info_t aic7[9x]xx_tag_info\[\] =/b notblob;
    /^char dmasound_alaw2dma8\[\] =/b notblob;
    /^char dmasound_ulaw2dma8\[\] =/b notblob;
    /^const struct aper_size_info_16 agp3_generic_sizes\[AGP_GENERIC_SIZES_ENTRIES\] =/b notblob;
    /^const u16 crc_itu_t_table\[256\] =/b notblob;
    /^const u8 byte_rev_table\[256\] =/b notblob;
    /^const u8 crc7_syndrome_table\[256\] =/b notblob;
    /^const unsigned char INIT_2\[127\] =/b notblob;
    /^int snd_sf_vol_table\[128\] =/b notblob;
    /^static	u_char	irq_to_siubit\[\] =/b notblob;
    /^static	u_char	irq_to_siureg\[\] =/b notblob;
    /^static Byte_t RData\[RDATASIZE\] =/b notblob;
    /^static __const__ __u16 gx_coeff\[256\] =/b notblob;
    /^static __u8 init7121ntsc\[\] =/b notblob;
    /^static __u8 init7121pal\[\] =/b notblob;
    /^static __u8 mode8420\(pro\|con\)\[\] =/b notblob;
    /^static byte capidtmf_leading_zeroes_table\[0x100\] =/b notblob;
    /^static char channel_map_madi_ss\[HDSPM_MAX_CHANNELS\] =/b notblob;
    /^static char coefficients\[NM_TOTAL_COEFF_COUNT \* 4\] =/b notblob;
    /^static char ecc_syndrome_table\[\] =/b notblob;
    /^static char isdn_audio_alaw_to_ulaw\[\] =/b notblob;
    /^static char isdn_audio_ulaw_to_alaw\[\] =/b notblob;
    /^static char mix_cvt\[101\] =/b notblob;
    /^static char opl3_volume_table\[128\] =/b notblob;
    /^static const RegInitializer initData\[\] __initdata =/b notblob;
    /^static const __u16 crc10_table\[256\] =/b notblob;
    /^static const __u32 crc_c\[256\] =/b notblob;
    /^static const char zr360[56]0_dht\[0x1a4\] =/b notblob;
    /^static const char zr360[56]0_dqt\[0x86\] =/b notblob;
    /^static const fixp_t cos_table\[46\] =/b notblob;
    /^static const int init_seq\[\] =/b notblob;
    /^static const int mobile_vid_table\[32\] =/b notblob;
    /^static const s16 snd_opl4_pitch_map\[0x600\] =/b notblob;
    /^static const s8 b43_tssi2dbm_b_table\[\] =/b notblob;
    /^static const s8 b43_tssi2dbm_g_table\[\] =/b notblob;
    /^static const s8 b43legacy_tssi2dbm_b_table\[\] =/b notblob;
    /^static const s8 b43legacy_tssi2dbm_g_table\[\] =/b notblob;
    /^static const s8 bcm43xx_tssi2dbm_b_table\[\] =/b notblob;
    /^static const s8 bcm43xx_tssi2dbm_g_table\[\] =/b notblob;
    /^static const s8 budtab\[256\] =/b notblob;
    /^static const struct aper_size_info_32 u3_sizes\[8\] =/b notblob;
    /^static const struct aper_size_info_8 via_generic_sizes\[9\] =/b notblob;
    /^static const struct color clut_vga16\[16\] =/b notblob;
    /^static const struct gain_entry gain_table\[2\]\[108\] =/b notblob;
    /^static const struct mV_pos __initdata mobilevrm_mV\[32\] =/b notblob;
    /^static const struct mV_pos __initdata vrm85_mV\[32\] =/b notblob;
    /^static const struct menelaus_vtg_value vcore_values\[\] =/b notblob;
    /^static const struct opl4_region regions_[0-9a-frums]*\[\] =/b notblob;
    /^static const struct regval regval_table\[\] =/b notblob;
    /^static const struct rf_channel rf_vals_5222\[\] =/b notblob;
    /^static const struct rf_channel rf_vals_5225_2527\[\] =/b notblob;
    /^static const struct rf_channel rf_vals_5226\[\] =/b notblob;
    /^static const struct rf_channel rf_vals_bg\[\] =/b notblob;
    /^static const struct rf_channel rf_vals_bg_2522\[\] =/b notblob;
    /^static const struct rf_channel rf_vals_bg_2523\[\] =/b notblob;
    /^static const struct rf_channel rf_vals_bg_2524\[\] =/b notblob;
    /^static const struct rf_channel rf_vals_bg_2525\[\] =/b notblob;
    /^static const struct rf_channel rf_vals_bg_2525e\[\] =/b notblob;
    /^static const struct rf_channel rf_vals_bg_2528\[\] =/b notblob;
    /^static const struct rf_channel rf_vals_noseq\[\] =/b notblob;
    /^static const struct rf_channel rf_vals_seq\[\] =/b notblob;
    /^static const u16 Sbox\[256\] =/b notblob;
    /^static const u16 count_lut\[\] =/b notblob;
    /^static const u16 e1000_igp_2_cable_length_table\[\] =/b notblob;
    /^static const u16 rtl8225bcd_rxgain\[\] =/b notblob;
    /^static const u16 rtl8225z2_rxgain\[\] =/b notblob;
    /^static const u16 stufftab\[5 \* 256\] =/b notblob;
    /^static const u16 tkip_sbox\[256\] =/b notblob;
    /^static const u16 wm8753_reg\[\] =/b notblob;
    /^static const u32 SS[0-3]\[256\] =/b notblob;
    /^static const u32 S[1-8]\[64\] =/b notblob;
    /^static const u32 T[0-5]\[256\] =/b notblob;
    /^static const u32 Tm\[24\]\[8\] =/b notblob;
    /^static const u32 bass_table\[41\]\[5\] =/b notblob;
    /^static const u32 bf_sbox\[256 \* 4\] =/b notblob;
    /^static const u32 camellia_sp0222\[256\] =/b notblob;
    /^static const u32 camellia_sp1110\[256\] =/b notblob;
    /^static const u32 camellia_sp3033\[256\] =/b notblob;
    /^static const u32 camellia_sp4404\[256\] =/b notblob;
    /^static const u32 crc32c_table\[256\] =/b notblob;
    /^static const u32 db_table\[101\] =/b notblob;
    /^static const u32 m8xx_size_to_gray\[M8XX_SIZES_NO\] =/b notblob;
    /^static const u32 mds\[4\]\[256\] =/b notblob;
    /^static const u32 pc2\[1024\] =/b notblob;
    /^static const u32 s[1-7]\[256\] =/b notblob;
    /^static const u32 sb8\[256\] =/b notblob;
    /^static const u32 tfrc_calc_x_lookup\[TFRC_CALC_X_ARRSIZE\]\[2\] =/b notblob;
    /^static const u32 treble_table\[41\]\[5\] =/b notblob;
    /^static const u64 [CT][0-7]\[256\] =/b notblob;
    /^static const u64 sbox[1-4]\[256\] =/b notblob;
    /^static const u64 sha512_K\[80\] =/b notblob;
    /^static const u8 Tr\[4\]\[8\] =/b notblob;
    /^static const u8 aes_sbox\[256\] =/b notblob;
    /^static const u8 calc_sb_tbl\[512\] =/b notblob;
    /^static const u8 exp_to_poly\[492\] =/b notblob;
    /^static const u8 legal_ansi_char_array\[0x40\] =/b notblob;
    /^static const u8 parity\[\] =/b notblob;
    /^static const u8 pc1\[256\] =/b notblob;
    /^static const u8 poly_to_exp\[255\] =/b notblob;
    /^static const u8 q[01]\[256\] =/b notblob;
    /^static const u8 ratio_lut\[\] =/b notblob;
    /^static const u8 rs\[256\] =/b notblob;
    /^static const u8 rtl8225_agc\[\] =/b notblob;
    /^static const u8 rtl8225_tx_power_cck\[\] =/b notblob;
    /^static const u8 rtl8225_tx_power_cck_ch14\[\] =/b notblob;
    /^static const u8 rtl8225z2_tx_gain_cck_ofdm\[\] =/b notblob;
    /^static const u8 setup\[\] =/b notblob;
    /^static const u8 speedtab \[3\]\[12\] =/b notblob;
    /^static const u_char irq_to_siubit\[\] =/b notblob;
    /^static const u_char irq_to_siureg\[\] =/b notblob;
    /^static const u_char nand_ecc_precalc_table\[\] =/b notblob;
    /^static const uint8_t parity\[256\] =/b notblob;
    /^static const unsigned char \(UV\|Y\)_QUANTABLE\[64\] =/b notblob;
    /^static const unsigned char __initdata mV_mobilevrm\[32\] =/b notblob;
    /^static const unsigned char __initdata mV_vrm85\[32\] =/b notblob;
    /^static const unsigned char barco_p1\[2\]\[9\]\[7\]\[3\] =/b notblob;
    /^static const unsigned char bitcounts\[256\] =/b notblob;
    /^static const unsigned char blue\[256\] =/b notblob;
    /^static const unsigned char chktab[hl]\[256\] =/b notblob;
    /^static const unsigned char comet_miireg2offset\[32\] =/b notblob;
    /^static const unsigned char euc2sjisibm_g3upper_map\[\]\[2\] =/b notblob;
    /^static const unsigned char init\[\] =/b notblob;
    /^static const unsigned char green\[256\] =/b notblob;
    /^static const unsigned char hash_table_ops\[64\*4\] =/b notblob;
    /^static const unsigned char hid_keyboard\[256\] =/b notblob;
    /^static const unsigned char mts_direction\[256\/8\] =/b notblob;
    /^static const unsigned char red\[256\] =/b notblob;
    /^static const unsigned char sjisibm2euc_map\[\]\[2\] =/b notblob;
    /^static const unsigned char vol_cvt_datt\[128\] =/b notblob;
    /^static const unsigned char wm_vol\[256\] =/b notblob;
    /^static const unsigned int MulIdx\[16\]\[16\] =/b notblob;
    /^static const unsigned int crctab32\[\] =/b notblob;
    /^static const unsigned short crc_flex_table\[\] =/b notblob;
    /^static const unsigned short logtable\[256\] =/b notblob;
    /^static const unsigned short wd7000_iobase\[\] =/b notblob;
    /^static const unsigned short x86_keycodes\[256\] =/b notblob;
    /^static const unsigned table\[\] =/b notblob;
    /^static int MV300_reg_8bit\[256\] =/b notblob;
    /^static int fifo_map\[\]\[MAX_TX_FIFOS\] =/b notblob;
    /^static int initial_lfsr\[\] =/b notblob;
    /^static int log_tbl\[129\] =/b notblob;
    /^static int logitech_expanded_keymap\[LOGITECH_EXPANDED_KEYMAP_SIZE\] =/b notblob;
    /^static int miro_fmtuner\[\]  =/b notblob;
    /^static int miro_tunermap\[\] =/b notblob;
    /^static int register_size\[\] =/b notblob;
    /^static int reserve_list\[MAX_RES_ARGS\] =/b notblob;
    /^static int reverse6\[64\] =/b notblob;
    /^static short attack_time_tbl\[128\] =/b notblob;
    /^static short beep_wform\[256\] =/b notblob;
    /^static short decay_time_tbl\[128\] =/b notblob;
    /^static short isdn_audio_[ua]law_to_s16\[\] =/b notblob;
    /^static struct cipher_testvec anubis_cbc_dec_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec anubis_cbc_enc_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec anubis_dec_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec anubis_enc_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec camellia_cbc_dec_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec camellia_cbc_enc_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec camellia_dec_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec camellia_enc_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec cast6_dec_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec cast6_enc_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec serpent_dec_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec serpent_enc_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec tea_dec_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec tea_enc_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec tf_dec_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec tf_enc_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec tnepres_dec_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec xeta_dec_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec xeta_enc_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec xtea_dec_tv_template\[\] =/b notblob;
    /^static struct cipher_testvec xtea_enc_tv_template\[\] =/b notblob;
    /^static struct comp_testvec deflate_decomp_tv_template\[\] =/b notblob;
    /^static struct hash_testvec aes_xcbc128_tv_template\[\] =/b notblob;
    /^static struct hash_testvec crc32c_tv_template\[\] =/b notblob;
    /^static struct hash_testvec hmac_sha256_tv_template\[\] =/b notblob;
    /^static struct hash_testvec sha256_tv_template\[\] =/b notblob;
    /^static struct hash_testvec sha384_tv_template\[\] =/b notblob;
    /^static struct hash_testvec sha512_tv_template\[\] =/b notblob;
    /^static struct hash_testvec wp256_tv_template\[\] =/b notblob;
    /^static struct hash_testvec wp384_tv_template\[\] =/b notblob;
    /^static struct hash_testvec wp512_tv_template\[\] =/b notblob;
    /^static struct iwl_tx_power power_gain_table\[2\]\[IWL_MAX_GAIN_ENTRIES\] =/b notblob;
    /^static struct ovcamchip_regvals regvals_init_\(76be\|7[16]20\|7x10\)\[\] =/b notblob;
    /^static struct regval_list ov7670_default_regs\[\] =/b notblob;
    /^static struct s_c2 SetRate48000\[\] =/b notblob;
    /^static struct tea6420_multiplex TEA6420_line\[MXB_AUDIOS+1\]\[2\] =/b notblob;
    /^static struct wm_info i810_wm_16_100\[\] =/b notblob;
    /^static struct wm_info i810_wm_16_133\[\] =/b notblob;
    /^static struct wm_info i810_wm_24_100\[\] =/b notblob;
    /^static struct wm_info i810_wm_24_133\[\] =/b notblob;
    /^static struct wm_info i810_wm_8_100\[\] =/b notblob;
    /^static struct wm_info i810_wm_8_133\[\] =/b notblob;
    /^static struct { struct fb_bitfield red, green, blue, transp; int bits_per_pixel; } colors\[\] =/b notblob;
    /^static u16 asEqCoefsPipes\[64\] =/b notblob;
    /^static u16 asEqCoefsZeros\[50\] =/b notblob;
    /^static u16 asEqOutStateZeros\[48\] =/b notblob;
    /^static u16 default_key_map \[256\] =/b notblob;
    /^static u16 eq_levels\[64\] =/b notblob;
    /^static u32  crc32tab\[\] __attribute__ ((aligned(8))) =/b notblob;
    /^static u32 ac3_frames\[3\]\[32\] =/b notblob;
    /^static u32 adwDecim8\[33\] =/b notblob;
    /^static u32 h_prescale\[64\] =/b notblob;
    /^static u32 v_gain\[64\] =/b notblob;
    /^static u8 cvs_time_value\[\]\[XFER_UDMA_6 - XFER_UDMA_0 + 1\] =/b notblob;
    /^static u8 SRAM_Table\[\]\[60\] =/b notblob;
    /^static u8 act_time_value\[\]\[8\] =/b notblob;
    /^static u8 alps_tdee4_stv0297_inittab\[\] =/b notblob;
    /^static u8 bnx2_5706_stats_len_arr\[BNX2_NUM_STATS\] =/b notblob;
    /^static u8 bnx2_5708_stats_len_arr\[BNX2_NUM_STATS\] =/b notblob;
    /^static u8 flit_desc_map\[\] =/b notblob;
    /^static u8 ini_time_value\[\]\[8\] =/b notblob;
    /^static u8 init_tab \[\] =/b notblob;
    /^static u8 mac_reader\[\] =/b notblob;
    /^static u8 mt2131_config1\[\] =/b notblob;
    /^static u8 mt2266_init2\[\] =/b notblob;
    /^static u8 opera1_inittab\[\] =/b notblob;
    /^static u8 rco_time_value\[\]\[8\] =/b notblob;
    /^static u8 saa7113_init_regs\[\] =/b notblob;
    /^static u8 samsung_tbmu24112_inittab\[\] =/b notblob;
    /^static u8 tas3004_treble_table\[\] =/b notblob;
    /^static u8 w1_crc8_table\[\] =/b notblob;
    /^static u_char const data_sizes_32\[32\] =/b notblob;
    /^static u_long ident_map\[32\] =/b notblob;
    /^static u_short ctrl_map\[NR_KEYS\] *=/b notblob;
    /^static u_short shift_ctrl_map\[NR_KEYS\] =/b notblob;
    /^static u_short shift_map\[NR_KEYS\] *=/b notblob;
    /^static uchar perm1\[56\] =/b notblob;
    /^static uchar perm2\[48\] =/b notblob;
    /^static uchar perm3\[64\] =/b notblob;
    /^static uchar perm4\[48\] =/b notblob;
    /^static uchar perm5\[32\] =/b notblob;
    /^static uchar perm6\[64\] =/b notblob;
    /^static uchar sbox\[8\]\[4\]\[16\] =/b notblob;
    /^static uint16_t crc_table\[256\] =/b notblob;
    /^static uint8_t lpfcAlpaArray\[\] =/b notblob;
    /^static uint8_t seqprog\[\] =/b notblob;
    /^static unsigned char V110_OffMatrix_9600\[\] =/b notblob;
    /^static unsigned char V110_OnMatrix_9600\[\] =/b notblob;
    /^static unsigned char a2232_65EC02code\[\] =/b notblob;
    /^static unsigned char alaw_main\[\] =/b notblob;
    /^static unsigned char atkbd_set3_keycode\[512\] =/b notblob;
    /^static unsigned char atkbd_unxlate_table\[128\] =/b notblob;
    /^static unsigned char banner_table\[\] =/b notblob;
    /^static unsigned char bootlogo_bits\[\] =/b notblob;
    /^static unsigned char bus2core_8260\[\] =/b notblob;
    /^static unsigned char bus2core_8280\[\] =/b notblob;
    /^static unsigned char caseorder\[256\] =/b notblob;
    /^static unsigned char crystal_key\[\] =/b notblob;
    /^static unsigned char dsp_ulaw\[\] =/b notblob;
    /^static unsigned char expressiontab\[128\] =/b notblob;
    /^static unsigned char header2\[\] =/b notblob;
    /^static unsigned char hidp_keycode\[256\] =/b notblob;
    /^static unsigned char ima_adpcm_capture\[\] =/b notblob;
    /^static unsigned char ima_adpcm_init\[\] =/b notblob;
    /^static unsigned char ima_adpcm_playback\[\] =/b notblob;
    /^static unsigned char irq_xlate\[32\] =/b notblob;
    /^static unsigned char mulaw_main\[\] =/b notblob;
    /^static unsigned char nkbd_keycode\[128\] =/b notblob;
    /^static unsigned char pan_volumes\[256\] =/b notblob;
    /^static unsigned char parm_block\[32\] =/b notblob;
    /^static unsigned char raw3270_ebcgraf\[64\] =/b notblob;
    /^static unsigned char rfcomm_crc_table\[256\] =/b notblob;
    /^static unsigned char rwa_unlock\[\] __initdata =/b notblob;
    /^static unsigned char seqprog\[\] =/b notblob;
    /^static unsigned char snd_opl4_volume_table\[128\] =/b notblob;
    /^static unsigned char splash_bits\[\] =/b notblob;
    /^static unsigned char sunkbd_keycode\[128\] =/b notblob;
    /^static unsigned char ufs_fragtable_8fpb\[\] =/b notblob;
    /^static unsigned char ufs_fragtable_other\[\] =/b notblob;
    /^static unsigned char ulaw_dsp\[\] =/b notblob;
    /^static unsigned char usb_kbd_keycode\[256\] =/b notblob;
    /^static unsigned char vga_font\[cmapsz\] \(BTDATA \|\)=/b notblob;
    /^static unsigned char voltab[12]\[128\] =/b notblob;
    /^static unsigned char vpd89_data\[\] =/b notblob;
    /^static unsigned char xtkbd_keycode\[256\] =/b notblob;
    /^static unsigned int ac3_bitrates\[32\] =/b notblob;
    /^static unsigned int bass_volume_table\[\] =/b notblob;
    /^static unsigned int bitrates\[3\]\[16\] =/b notblob;
    /^static unsigned int isa_dma_port\[8\]\[7\] =/b notblob;
    /^static unsigned int master_volume_table\[\] =/b notblob;
    /^static unsigned int mixer_volume_table\[\] =/b notblob;
    /^static unsigned int pan_table\[63\] =/b notblob;
    /^static unsigned int snapper_bass_volume_table\[\] =/b notblob;
    /^static unsigned int snapper_treble_volume_table\[\] =/b notblob;
    /^static unsigned int treble_volume_table\[\] =/b notblob;
    /^static unsigned int valid_mem\[\] =/b notblob;
    /^static unsigned long arthur_to_linux_signals\[32\] =/b notblob;
    /^static unsigned long shmedia_opcode_table\[64\] =/b notblob;
    /^static unsigned nv\([34]\|10\)TableP\(FIFO\|GRAPH\|RAMIN\)\[\]\[2\] =/b notblob;
    /^static unsigned short fcstab\[256\] =/b notblob;
    /^static unsigned short init[1234]\[128\] \/\*__devinitdata\*\/ =/b notblob;
    /^static unsigned short log_table\[LOG_TABLE_SIZE\*2\] =/b notblob;
    /^static unsigned short rc_ioport\[\] =/b notblob;
    /^static unsigned short translations\[\]\[256\] =/b notblob;
    /^static unsigned short treble_parm\[12\]\[9\] =/b notblob;
    /^struct RGBColors TextCLUT\[256\] =/b notblob;
    /^struct VgaRegs GenVgaTextRegs\[NREGS+1\] =/b notblob;
    /^struct battery_thresh  spitz_battery_levels_noac\[\] =/b notblob;
    /^struct battery_thresh spitz_battery_levels_acin\[\] =/b notblob;
    /^struct fb_bitfield rgb_bitfields\[\]\[4\] =/b notblob;
    /^struct mode_registers std_modes\[\] =/b notblob;
    /^struct vmode_attr vmode_attrs\[VMODE_MAX\] =/b notblob;
    /^u16 const crc16_table\[256\] =/b notblob;
    /^u16 const crc_ccitt_table\[256\] =/b notblob;
    /^u16 hfsplus_compose_table\[\] =/b notblob;
    /^u16 hfsplus_decompose_table\[\] =/b notblob;
    /^u_char const data_sizes_16\[32\] =/b notblob;
    /^u_short alt_map\[NR_KEYS\] =/b notblob;
    /^u_short altgr_map\[NR_KEYS\] =/b notblob;
    /^u_short ctrl_alt_map\[NR_KEYS\] =/b notblob;
    /^u_short ctrl_map\[NR_KEYS\] *=/b notblob;
    /^u_short plain_map\[NR_KEYS\] *=/b notblob;
    /^u_short shift_ctrl_map\[NR_KEYS\] =/b notblob;
    /^u_short shift_map\[NR_KEYS\] *=/b notblob;
    /^uint patch_2[0f]00\[\] =/b notblob;
    /^uint16_t e1000_igp_cable_length_table\[IGP01E1000_AGC_LENGTH_TABLE_SIZE\] =/b notblob;
    /^uint16_t e1000_igp_2_cable_length_table\[IGP02E1000_AGC_LENGTH_TABLE_SIZE\] =/b notblob;
    /^} euc2sjisibm_jisx0212_map\[\] =/b notblob;
    /^} freq\[\] =/b notblob;
    /^} hps_h_coeff_tab \[\] =/b notblob;
    /^} hps_v_coeff_tab \[\] =/b notblob;
    /^} init_tab\[\] =/b notblob;
    /^} maven_gamma\[\] =/b notblob;
    /^} mem_table\[\] =/b notblob;
    /^} mxb_saa7740_init\[\] =/b notblob;
    /^} pll_table\[\] =/b notblob;
    /^} qam256_snr_tab\[\] =/b notblob;
    /^} qam64_snr_tab\[\] =/b notblob;
    /^} sil_port\[\] =/b notblob;
    /^} vsb_snr_tab\[\] =/b notblob;
    /^} yss225_registers\[\] __devinitdata =/b notblob;
    '
    ;;
  */patch*2.6.25-rc*.bz2)
    spex='
    /^;[/][*]@@ -[0-9]*,[0-9]* +[0-9]*,[0-9]* @@ static uchar sbox\[8\]\[4\]\[16\] = {[*][/];$/b collect_blob_begin;
    '
    sedx='
    /^	\$3 = {{pge = /b notblob;
    /^static yyconst flex_int\(16\|32\)_t yy_[^[]*\[[0-9]*\] =/b notblob;
    /^static const yytype_u\?int\(8\|16\) yy[^[]*\[\] =/b notblob;
    /^	int bcomm_irq\[3\*16\] =/b notblob;
    /^	static const int8 countLeadingZerosHigh\[\] =/b notblob;
    /^static unsigned long shmedia_opcode_table\[64\] =/b notblob;
    /^u_char const data_sizes_16\[32\] =/b notblob;
    /^static u_char const data_sizes_32\[32\] =/b notblob;
    /^[ 	]*\.\(digest\|entries\|input\|key\|output\|plaintext\|result\)[ 	]*= {/b notblob;
    /^static struct .*_testvec .*_tv_template\[\] =/b notblob;
    /^static struct nic_qp_map nic_qp_mapping_[01]\[\] =/b notblob;
    /^static u8 mt2266_init2\[\] =/b notblob;
    /^static struct regval ov_initvals\[\] =/b notblob;
    /^static struct regval stk1125_initvals\[\] =/b notblob;
    /^static u8 bnx2x_stats_len_arr\[BNX2X_NUM_STATS\] =/b notblob;
    /^static const struct arb_line read_arb_data\[NUM_RD_Q\]\[MAX_RD_ORD + 1\] =/b notblob;
    /^static const struct arb_line write_arb_data\[NUM_WR_Q\]\[MAX_WR_ORD + 1\] =/b notblob;
    /^uint16_t e1000_igp_cable_length_table\[IGP01E1000_AGC_LENGTH_TABLE_SIZE\] =/b notblob;
    /^uint16_t e1000_igp_2_cable_length_table\[IGP02E1000_AGC_LENGTH_TABLE_SIZE\] =/b notblob;
    /^#define AR5K_RATES_11A /b notblob;
    /^#define AR5K_RATES_11B /b notblob;
    /^#define AR5K_RATES_11G /b notblob;
    /^#define AR5K_RATES_TURBO /b notblob;
    /^#define AR5K_RATES_XR /b notblob;
    /^		} blinkrates\[\] =/b notblob;
    /^static const struct ath5k_ini ar5212_ini\[\] =/b notblob;
    /^static const struct ath5k_ini_mode rf5413_ini_mode_end\[\] =/b notblob;
    /^static const struct ath5k_ini_rf rfregs_5111\[\] =/b notblob;
    /^static const struct ath5k_ini_rf rfregs_5112\[\] =/b notblob;
    /^static const struct ath5k_ini_rf rfregs_5112a\[\] =/b notblob;
    /^static const struct ath5k_ini_rf rfregs_5413\[\] =/b notblob;
    /^static const u16 rtl8225bcd_rxgain\[\] =/b notblob;
    /^static const u8 rtl8225_agc\[\] =/b notblob;
    /^static const u8 rtl8225_tx_power_cck\[\] =/b notblob;
    /^static const u8 rtl8225_tx_power_cck_ch14\[\] =/b notblob;
    /^static const u16 rtl8225z2_rxgain\[\] =/b notblob;
    /^;[/][*]@@ -[0-9]*,[0-9]* +[0-9]*,[0-9]* @@ static uchar sbox\[8\]\[4\]\[16\] = {[*][/];/b notblob;
    /^     \( 49,\)*[\n]\([ 0-9,]*[\n]\)*     \( 49,\)*[\n][*][/][;]\([\n];[/][*];@@ -[0-9]*,[0-9]* +[0-9]*,[0-9]* @@ kconf_id_hash (register const char \*str, register unsigned int len)[*][/];\)\?$/b notblob;
    /^static const unsigned char wm_vol\[256\] =/b notblob;
    /^domain<N> <cpumask> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36[\n]/b notblob;
    /^static const u16 e1000_igp_2_cable_length_table\[\] =/b notblob;
    /^	24 => \[[\n]\(.*[\n]\)*	\]\(, [0-9]\+ => \[\)\?$/b notblob;
    /^		'"'"'0x.*[\n]\(.*[\n]\)*	\]\(, [0-9]\+ => \[\)\?$/b notblob;
    /^const u\(8\|16\|32\) b43_ntab_\(\(adjustpower\|estimatepowerlt\|gainctl\|iqlt\|loftlt\|noisevar1\|tdi[24]0a\)[01]\|channelest\|frame\(lookup\|struct\)\|mcs\|pilot\|tdtrn\|tmap\)\[\] =/b notblob;
    '
    ;;
  */nouveau-drm.patch)
    sedx='
    /^\(static uint32_t\|}\) nv04_graph_ctx_regs \[\] =/b notblob;
    /^static int nv10_graph_ctx_regs \[\] =/b notblob;
    # this is highly suspicious, but it does not look like the
    # developers are trying to stop anyone from modifying it,
    # they just grabbed these numbers from mmio interactions.
    /^static uint32_t nv\(4[013467ace]\|49_4b\|8[46]\)_ctx_voodoo\[\] =/b notblob;
    '
    ;;
  */linux-2.6-lirc.patch)
    sedx='/^const unsigned char map_table\[\] =/b notblob;'
    ;;
  */linux-2.6-modsign-mpilib.patch)
    sedx='/^const unsigned char __clz_tab\[\] =/b notblob'
    ;;
  */linux-2.6-wireless.patch)
    sedx='
    /^const u\(8\|16\|32\) b43_ntab_\(\(adjustpower\|estimatepowerlt\|gainctl\|iqlt\|loftlt\|noisevar1\|tdi[24]0a\)[01]\|channelest\|frame\(lookup\|struct\)\|mcs\|pilot\|tdtrn\|tmap\)\[\] =/b notblob;
    /^static const u16 rtl8225bcd_rxgain\[\] =/b notblob;
    /^static const u8 rtl8225_agc\[\] =/b notblob;
    /^static const u8 rtl8225_tx_power_cck\[\] =/b notblob;
    /^static const u8 rtl8225_tx_power_cck_ch14\[\] =/b notblob;
    /^static const u16 rtl8225z2_rxgain\[\] =/b notblob;
    /^static const struct ath5k_ini_rf rfregs_5111\[\] =/b notblob;
    /^static const struct ath5k_ini_rf rfregs_5112\[\] =/b notblob;
    /^static const struct ath5k_ini_rf rfregs_5112a\[\] =/b notblob;
    /^static const struct ath5k_ini_rf rfregs_5413\[\] =/b notblob;
    /^#define AR5K_RATES_11A /b notblob;
    /^#define AR5K_RATES_11B /b notblob;
    /^#define AR5K_RATES_11G /b notblob;
    /^#define AR5K_RATES_TURBO /b notblob;
    /^#define AR5K_RATES_XR /b notblob;
    /^static const struct ath5k_ini ar5212_ini\[\] =/b notblob;
    /^static const struct ath5k_ini_mode rf5413_ini_mode_end\[\] =/b notblob;
    /^		} blinkrates\[\] =/b notblob;
    '
    ;;
  */linux-2.6-wireless-pending.patch)
    sedx='
    /^#define AR5K_RATES_11A /b notblob;
    /^#define AR5K_RATES_11B /b notblob;
    /^#define AR5K_RATES_11G /b notblob;
    /^#define AR5K_RATES_TURBO /b notblob;
    /^#define AR5K_RATES_XR /b notblob;
    /^static const struct ath5k_ini_mode rf2413_ini_mode_end\[\] =/b notblob;
    /^   sudo modprobe ath5k debug=0x00000400[\n]/b notblob;
    /^     rates:[\n]/b notblob;
    /^	{ 1, MODULATION_XR, 3000, 1, 150, 3 },		\\[\n]\(.*\\[\n]\)*}/b notblob;
    '
    ;;
  */linux-2.6-drm-i915-modeset.patch)
    sedx='
    /^static const u32 filter_table\[\] =/b notblob;
    '
    ;;
  esac

  # turn "/^rx1[\n]rx2/b notblob;\n/^rx3/b notblob;..." into
  # "/^rx1$\|^rx3\|.../b mayblob;"
  sedfx=`
    echo "$sedx" |
    sed '
	/^[ 	]*\/.*\/b notblob;$/!d;
	s,b notblob;$,,;
	s,\\[\\\\n\\].*\/$,\\\\([\\\\n]\\\\|$\\\\)/,;
	s,/$,/b mayblob;,;
	' |
    sed ': start; N; s,/b mayblob;[\n][ 	]*/,\\\\|,; t start'
  `

  # turn "/rx1/b notblob;\n/rx2/b notblob;..." into
  # "/rx1\|rx2\|.../b notblob;"
  case $sedx in
  */*/"b notblob;"*/*/"b notblob;"*)
    sedx=`{
	echo;
	echo "$sedx" | sed '/^[ 	]*\(#\|$\)/d'
      } |
      sed -n '
      : top
      $!{ N; b top; }
      ${
        : retry
        s,\([\n][ 	]*/[^\n]*\)/b notblob;[\n][ 	]*/\([^\n]*/b notblob;\),\1\\\\|\2,g
        t retry
        p;
	q;
      }'`
    ;;
  esac
}  

# Regular expression that matches a literal constant.
constx="[0-9][0-9a-fA-FxX]*"
# Regular expression that matches a separator between consecutive
# literal constants.
sepx="\\([,:{} 	LlUu\"\'\\\\\\n]\\+[xX\$]\\?\\|[ 	\\n]*[.][a-zA-Z][a-zA-Z0-9]*[ 	]\\+[\$]\\?\\)"
# Regulat expression that matches an unterminated /*C*/ comment.
unfcomment="/[/][*]\\([^*]\\|[*][*]*[^*/]\\|[*]*[\\n]\\)*[*]*\$/"

# Set up the sed script that will go through the (processed) input,
# looking for sequences of blobs and printing whatever was requested.

set_sedmain () {
  # Concatenate lines as long as the end of the current line ends with
  # a literal constant or characters that generally precede bracketed
  # assignments, followed or not by separators.  This ensures that, if
  # there is a blob somewhere, it will be in a single line.  It's also
  # the fastest mechanism, unlike the other collectors below, that, by
  # trying to preserve more context, end up selecting too large
  # expressions.  We only want them to recognize known false
  # positives, or to find new blobs while getting their surrounding
  # context.
  collect_blob="
: collect_blob
/\\($constx\\|[:={\\n]\\)\\($sepx\\)\\?$/ {
  : collect_blob_begin
  \$!N;
  \$!b collect_blob;
}
"

  # Concatenate as many lines as needed to get a complete /*C*/
  # comment in.
  collect_comment="
/[/][*/]/{
  : collect_comment
  \$! { $unfcomment {
    N;
    b collect_comment;
  } }
}
"
  # Concatenate as many lines as needed to get a complete #define in,
  # even if it contains comments or backslash-continued lines.
  collect_define="
/^[ 	]*#[ 	]*define[ 	]/ {
  /\\\\[ 	]*\$/! b recheck;
  : collect_define
  \$! { $unfcomment {
    N;
    b collect_define;
  } }
  h;
  \$ b collect_end;
  n;
  : collect_define_loop
  \$! { $unfcomment {
    N;
    b collect_define_loop;
  } }
  H;
  \$ b collect_end
  /\\\\[ 	]*\$/ {
    n;
    b collect_define_loop
  }
  b collect_end;
}
"

  # Concatenate as many lines as needed to get to the end (;) of an
  # initialized declaration.  We don't try to be too clever WRT
  # semicolons in comments, strings, etc.
  collect_init="
# We could skip semicolons in comments here, but it's probably not worth it.
/[=][^;]*\$/ {
  : collect_begin
  \$! {
    $unfcomment {
      N;
      b collect_begin;
    }
    /=[^;]\\([\\n][^;]*\\)*;.*$/b collect_abort;
  }
  : collect_init
  h;
  \$ b collect_end;
  n;
  : collect_loop
  \$! { $unfcomment {
    N;
    b collect_loop;
  } }
  H;
  \$ b collect_end;
  /;\([^\n*]*\|[*]*[^*/]\)*$/b collect_end;
  /^#\\|[/][/*]\\|^[ 	]*\$\\|[{},=:\\\\0-9][{},:\\\\0-9a-fA-FxX\"\' 	]*\$/ {
    n;
    b collect_loop;
  }
  : collect_end
  g;
  : collect_abort
}
"

  # This is the default (slow) definition of collect, getting as much
  # context as possible.  It must define labels mayblob (first line
  # matches that of a false positive).
  collect="
: mayblob
$v:mayblob
$collect_comment
$collect_define
$collect_init
$collect_blob
"

  # This is the default (slow) definition of skiplonglines, that skips
  # an optimization to print quickly initial lines that don't match a
  # blob, even if the pattern does contain a blob.
  skiplonglines=

  case $1 in
  -f)
    # With -f (for fast, passed by most callers of set_sedmain), use
    # collect_blob only, except for patterns that match sedfx.
    collect="
$collect_blob
b recheck
$collect
"

    # If a line doesn't start a false positive or a sequence worthy of
    # investigation, can go ahead and print it right away.
    skiplonglines="b noblobline;" ;
    shift;
    ;;
  esac

  sedmain="
$v:???spex
$spex
$v:---spex
$v:???sedfx
$sedfx
$v:---sedfx
/\\($constx\\|[:={\\n]\\)\($sepx\)\?$/b collect;
$skiplonglines
: collect
$v:collect
$collect
: recheck
$v:recheck
$sedx
$v:???shortmatch
/^[^\\n]*$constx\\($sepx$constx\\)\\{$sens\\}/{
  b blob;
}
$skiplonglines
# These help us print longer matches.  Not useful if not printing blobs.
$v:???longmatch
/^[^:\\n]*:[^\\n]*[\\n][^\\n]*$constx\\($sepx$constx\\)\\{$sens\\}\
\\|^[ 	]*#[ 	]*define[ 	]*\\([^\n]*\\|\\\\[ 	]*[\\n]\\|[/][*]\\([^*]\\|[*]\\+[^/]\\|[*]*[\\n]\\)*[*][/]\\)*$constx\\($sepx$constx\\)\\{$sens\\}\
\\|^[^\\n]*=\\([^{;\\n]*\\|[/][*]\\([^*]\\|[*]\\+[^/]\\|[*]*[\\n]\\)*[*][/]\\)*[\\n]\\?\\([^{;\\n]*\\|[/][*]\\([^*]\\|[*]\\+[^/]\\|[*]*[\\n]\\)*[*][/]\\)*{\\([^;\\n]*\\|[\\n]\\|[/][*]\\([^*]\\|[*]\\+[^/]\\|[*]*[\\n]\\)*[*][/]\\)*$constx\\($sepx$constx\\)\\{$sens\\}/b blob;
$v:---longmatch
b noblobline;
: noblob
$v:noblob
$5
b notblob
: deblobbed
$v:deblobbed
$4
b recheck
: notblob
$v:notblob
$3
d;
: noblobline
$v:noblobline
$2
D;
: blob
$v:blob
$1
d;
: deblob
$v:deblob
s/{[{ 	\n]*$constx\\($sepx$constx\\)\\{$sens,\\}}[ 	]*;/{\/*(DEBLOBBED)*\/};/g
t deblobbed_some
$v:none-deblobbed
s/$constx\\($sepx$constx\\)\\{$sens,\\}/\/*(DEBLOBBED)*\//g
t deblobbed
b noblobline
: deblobbed_some
$v:deblobbed_some
s/$constx\\($sepx$constx\\)\\{$sens,\\}/\/*(DEBLOBBED)*\//g
t deblobbed
b noblobline
"
}

# Process an input file named in $1 and run it through the blob
# recognizer.  Functions set_except and set_sed_cmd provide additional
# arguments on a per-file and per-action basis.

check () {
  case "$#" in 1) ;; *) echo ICE >&2; exit 1;; esac

  set_except "$1"

  set_sed_cmd "$1"

  # Choose the input source...
  case $1 in
  -) in= ;;
  *) in='< "$1"' ;;
  esac

  # Decompress as needed...
  case $1 in
  *.bz2) cmd1='bunzip2' ;;
  *.gz) cmd1='gunzip' ;;
  *) cmd1='cat' ;;
  esac

  # Extract or otherwise munge...
  case $1 in
  *.tar*)
    cmd2="tar -xf - --to-command='echo \";/*begin \$TAR_FILENAME*/;\"; cat; echo \";/**/;\"; echo \";/*end \$TAR_FILENAME*/;\"'";;
  *patch* | *diff*)
    sedpatch='
      /^[-]/d;
      /^\(@@\|+++\) / {
	i\
*/;
	s,^,;/*,;
	s,$,*/;,;
      };
      s,^[ +],,;'
    cmd2='sed "$sedpatch"' ;;
  *)
    cmd2='cat' ;;
  esac

  # Then run through the selected action.
  cmd3='sed -n "$sedmain"'

  # Optimize useless "cat"s away.
  pipe="$cmd1 | $cmd2 | $cmd3"
  while :; do
    case "| $pipe |" in
    *"| cat |"*)
      pipe=`echo "| $pipe |" | sed 's,| cat |,|,g;s,^| ,,;s, |$,,;s,^|$,cat,'`
      ;;
    *)
      break ;;
    esac
  done

  # Do it.
  eval $in $pipe
}

# If no input given, use stdin.
case $# in
0)
  test -t 0 && echo reading from standard input >&2
  set fnord -
  shift
  ;;
esac

# The lines below commented out out #list: can be used to get a list
# of matching inputs.  ATM this is useless, so we just use a shell
# boolean.

#list: n=$#
pass=:

# Go through each of the input files in the command line.
for file
do
  # If we print anything whatsoever (even a blank line) while
  # processing it, we've failed.
  if check "$file" | grep '.*'; then
      pass=false
      #list: set fnord "$@" "$file"
      #list: shift
  fi
done

#list: shift $n

#list: exec test $# = 0
$pass
exit
